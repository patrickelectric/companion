{% include ../_includes/header.liquid %}
<link href="css/bootstrap-switch.css" rel="stylesheet">
<script src="js/bootstrap-switch.js"></script>
<link href="css/bootstrap-select.css" rel="stylesheet">
<script src="js/bootstrap-select.js"></script>
<link href="css/bootstrap-slider.css" rel="stylesheet">
<script src="js/bootstrap-slider.js"></script>

<script>
	const PIPELINES = {
		"udp": {
			"pipeline_elements": [
				"v4l2src device=${camera}",
				"video/x-h264,width=${width},height=${height},framerate=${framerate}/1,type=video",
				"h264parse",
				"queue",
				"rtph264pay config-interval=10 pt=96",
				"multiudpsink clients=${clients}"
			],
			"endpoint_prefix": 'udp://',
		},
		"rtsp": {
			"pipeline_elements": [
				"v4l2src device=${camera}",
				"video/x-h264,width=${width},height=${height},framerate=${framerate}/1,type=video",
				"rtph264pay name=pay0"
			],
			"endpoint_prefix": 'rtsp://',
		}
	}

	var socket = io();

	var _cameras = [];
	var _activeFormat = {};
	
	var _allLoaded = false;
	
	const GST_PARAM_FILE = 'gstreamer2.param';

	function changeStreamType(streamType) {
		console.log(`Updating selected stream option to: ${streamType}`)
		const streamTypeSelect = document.getElementById("stream-type-select")
		for (var index in streamTypeSelect.options) {
			var option = streamTypeSelect.options[index]
			if (option.innerHTML == streamType) {
				streamTypeSelect.selectedIndex = index
				$("select").selectpicker('refresh')
				break
			}
		}
	}

	function loadOptions() {
		$.get('/pipelines', function(data) {
			console.log(`Load pipeline: ${JSON.stringify(data)}`)
			const videoConfiguration = data.videos_configuration[0]			

			// String that represents the type of stream. E.g: 'udp', 'rtsp', ...
			const streamType = (function() {
				for (const [streamType, content] of Object.entries(PIPELINES)) {
					if (videoConfiguration.endpoint.includes(content.endpoint_prefix)) {
						return streamType
					}
				}
			})()
			
			/**
			 * Fetch data from attributions like [caps string](https://gstreamer.freedesktop.org/documentation/additional/design/caps.html),
			 * following the syntax 'variable=value'.
			 * The result is a dict that contains a key for each variable and the value as the value of the key.
			 * Right now it supports: width, height, framerate and clients for multiudpsink
			 */
			const values = (function() {
				var result = {}

				// Get basic information
				for (var key of ['width', 'height', 'framerate']) {
					const regex = eval(`/${key}=(?<${key}>\\d+)/`)
					const [_, match] = regex.exec(videoConfiguration.pipeline)
					result[key] = match
				}
		
				switch (streamType) {
					case 'udp':
						// Get regex that match with <IP:port,IP:port..>
						const regex = /clients=(?<clients>[A-z|0-9|.|:|,]+)/
						const [_, match] = regex.exec(videoConfiguration.pipeline)
						result['clients'] = match

					default:
						console.log(`Can't parse ${streamType} since it does not have clients configuration.`)
				}
				
				return result
			})()

			// Update interface controls based in the values extracted from the pipeline

			// Update stream option
			changeStreamType(streamType)

			// And force the update of the menu
			streamTypeChanged()

			// Update client input
			const menuClientElement = document.getElementById(streamType + '-clients')
			if (menuClientElement != null) {
				menuClientElement.value = values.clients
			}
			
			// Update frame size input
			const frameSize = [values.width, values.height].join('x')
			console.log(`Updating selected frame size to: ${frameSize}`)
			$('#frame-size-select').val(frameSize).change()
			
			// Update framerate input
			console.log(`Updating selected framerate to: ${values.framerate}`)
			$('#framerate-select').val(values.framerate).change()
		})
	}
	
	function getCameraSelection() {
		return document.getElementById("camera-select").value;
	}

	function getFormatSelection() {
		return document.getElementById("format-select").value;
		
	}
	
	function getFrameSizeSelection() {
		return document.getElementById("frame-size-select").value;
	}
	
	function getFpsSelection() {
		return document.getElementById("framerate-select").value;
	}

	function getCameraById(id) {
		var ret = undefined
		_cameras.forEach(function(camera) {
			if (camera.device == id) {
				console.log("found match");
				ret = camera;
			}
		});
		
		return ret;
	}
	
	var formats = {};
	
	function disableAll(disable) { 
		console.log("disabled:",disable);
		$(".panel-body *").attr("disabled", disable);
		$("select").selectpicker('refresh');
		if(disable) {
			$("input[type=range]").slider("disable");
		} else {
			$("input[type=range]").slider("enable");
		}
		$("input[camera_bool]").bootstrapSwitch('disabled', disable);
	}

	function updateFramerateOptions() {
		console.log(`Update options for framerate: ${getFpsSelection()}`);

		$("select").selectpicker();

		if (!_allLoaded) {
			console.log("abort set format: still loading");
			return;
		}
		
		_activeFormat.format = formats[getFormatSelection()].formatName;
		_activeFormat.frameSize = getFrameSizeSelection();
		_activeFormat.frameRate = getFpsSelection();
		_activeFormat.device = getCameraSelection();
	}

	function updateFrameSizeOptions() {
		console.log(`Update options for frame size: ${getFrameSizeSelection()}`);
		
		var fps_select = document.getElementById("framerate-select");
		
		var old_selection = fps_select.options.length ? fps_select.options[fps_select.selectedIndex].value : null;
		
		// delete all children
		while (fps_select.firstChild) {
			fps_select.removeChild(fps_select.firstChild);
		}
		
		formats[getFormatSelection()].frameSizes[getFrameSizeSelection()].forEach(function(fps) {
			var option = document.createElement("option");
			option.innerHTML = fps;
			option.value = fps;
			option.selected = option.value == _activeFormat.frameRate;
			fps_select.appendChild(option);
		});
		
		updateFramerateOptions();
	}

	function updateFormatOptions() {
		console.log(`Update options for format selection: ${getFormatSelection()}`);

		var frame_size_select = document.getElementById("frame-size-select");
		
		var old_selection = frame_size_select.options.length ? frame_size_select.options[frame_size_select.selectedIndex].value : null;
		
		while (frame_size_select.firstChild) {
			frame_size_select.removeChild(frame_size_select.firstChild);
		}
	
		for(var frame_size in formats[getFormatSelection()].frameSizes) {
			var option = document.createElement("option");
			option.innerHTML = frame_size;
			option.value = frame_size;
			option.selected = option.value == _activeFormat.frameSize;
			frame_size_select.appendChild(option);
		}
		
		updateFrameSizeOptions();
	}

	socket.on('v4l2 cameras', function(data) {
		console.log("got cameras", data);
		
		_allLoaded = false;
		if (!data) {
			return;
		}
		_cameras = data.cameras;
		
		_activeFormat = data.activeFormat;
		
		var profileSelect = document.getElementById("v4l2 profile select");
		
		while (profileSelect.firstChild) {
			profileSelect.removeChild(profileSelect.firstChild);
		}
		
		var option = document.createElement("option");
		option.selected = true;
		profileSelect.appendChild(option);
		
		for (var profile in data.profiles) {
			var option = document.createElement("option");
			option.innerHTML = profile;
			option.value = profile;
			option.selected = option.value == data.activeProfile;
			profileSelect.appendChild(option);
		}
		
		profileSelect.onchange = function(data) {
			var name = profileSelect.options[profileSelect.selectedIndex].value;
			if (!name) {
				console.log("no name for profile!");
				return;
			}
			disableAll(true);
			socket.emit("load v4l2 profile", name);
		}
		
		var cameraSelect = document.getElementById("camera-select");
		
		if (!cameraSelect) {
			cameraSelect = document.createElement("select");
			cameraSelect.id = "camera-select";
		}

		while (cameraSelect.firstChild) {
			cameraSelect.removeChild(cameraSelect.firstChild);
		}
		
		_cameras.forEach(function(camera) {
			var option = document.createElement("option");
			option.innerHTML = camera.device;
			option.value = camera.device;
			if (camera.device == _activeFormat.device) {
				option.selected = true;
			}
			cameraSelect.appendChild(option);
		});
		
		cameraSelect.onchange = function() {
			cameraSelected();
			document.getElementById("v4l2 profile select").selectedIndex = 0; // Reset profile selection, they are per-camera only
		}

		cameraSelected();
		
		_allLoaded = true;
		
		disableAll(false);
	});
	
	function resetDefaults() {
		socket.emit('reset v4l2 defaults', getCameraSelection());
	}
	
	function cameraSelected() {
		var sliderContainer = document.getElementById("v4l2controls");
		sliderContainer.innerHTML = "";
		
		console.log("camera selected!", getCameraSelection());
		
		var camera = getCameraById(getCameraSelection());
		
		camera.controls.forEach(function(control) {
			
			var new_element;
			new_element = document.createElement('input');
			
			var h5 = document.createElement('h5');
			h5.innerHTML = control.name;

			if (control.type == "bool") {
				new_element.type = "checkbox";
				new_element.camera_bool = true;
				new_element.checked = control.value;
				
				new_element.onchange = function(data) {
					console.log('set v4l2 control', new_element.name, new_element.id, new_element.checked);
					
					/*
					var el = document.getElementById("CTRL_" + new_element.name.replace(", Auto", ""));
					if (el && el != new_element) {
						console.log("found", el);
						console.log("checked:", new_element.checked);
						el.disabled = new_element.checked;
						el.style.opacity = 0.5 + !new_element.checked * 0.5;
					}
					*/
					
					socket.emit('set v4l2 control', {
						device: camera.device,
						id: new_element.ctrl_id,
						value: new_element.checked
					});
				}
			} else if (control.type == "int" || control.type == "int_menu") {
				var h6 = document.createElement('h6');
				h6.style.display = "inline";
				h6.innerHTML = "\t" + control.value;
				h5.appendChild(h6);
	
				new_element.type = "range";
				new_element.class = "slider";
				new_element.min = control.min;
				new_element.max = control.max;
				new_element.step = control.step;
				new_element.value = control.value;
				new_element.setAttribute('data-slider-min', control.min);
				new_element.setAttribute('data-slider-max', control.max);
				new_element.setAttribute('data-slider-step', control.step);
				new_element.setAttribute('data-slider-value', control.value);
				/*
				// The effects of some controls are dictated by the current value of others
				// ie. we can't set the white balance temp control while the auto white balance control is enabled.
				var el = document.getElementById("CTRL_" + control.name + ", Auto");
				if (el) {
					console.log("found", el);
					new_element.disabled = el.checked;
					new_element.style.opacity = 0.5 + !el.checked * 0.5;
				}
				*/
					
				new_element.onslideStop = function(data) {
					h6.innerHTML = "\t" + new_element.value;
					control.value = new_element.value;
					console.log('set v4l2 control', new_element.name, new_element.id, new_element.value);
					socket.emit('set v4l2 control', {
						device: camera.device,
						id: new_element.ctrl_id,
						value: new_element.value
					});
				}
				
			} else if (control.type == "menu") {
				new_element = document.createElement('select');
				var i = 0;
				control.menu.forEach(function(menuItem) {
					if (menuItem != "") {
						var option = document.createElement("option");
						option.innerHTML = menuItem;
						option.value = i;
						new_element.appendChild(option);
						if (control.value === i) {
							// Set selected option to the current one (we can't use 'i' here because empty options are skipped)
							new_element.selectedIndex = new_element.children.length - 1;
						}
					}
					i = i + 1;
				});

				new_element.onchange = function(data) {
					control.value = new_element.value;
					console.log('set v4l2 control', new_element.name, new_element.id, new_element.value);
					socket.emit('set v4l2 control', {
						device: camera.device,
						id: new_element.ctrl_id,
						value: new_element.value
					});
				}

			} else if (control.type == "class") {
				h5.innerHTML = "";
				new_element = document.createElement("h4");
				new_element.innerHTML = control.name;
			} else {
				console.log('skipping unsupported type:', control.name, control.type);
				return;
			}
				
			new_element.ctrl_id = control.id;
			new_element.name = control.name;
	
			new_element.id = "CTRL_" + control.name;
			
			var exists = false;
			
			$.each(sliderContainer.childNodes, function(child) {
				if (child.id == new_element.id) {
					exists = true;
					// break;
				}
			});
			
			if (!exists) {
				sliderContainer.appendChild(h5);
				sliderContainer.appendChild(new_element);
				if(new_element.camera_bool) {
					$(new_element).bootstrapSwitch();
				} else if($(new_element).is('select')) {
					$(new_element).selectpicker();
				} else if(new_element.type == 'range') {
					$(new_element).slider({tooltip:'hide'});
				}
			}
		});
		
		// <binary format flag>: {
		//     formatName: "H264"
		//     frameSizes:
		//         {
		//             720x1080: [5,10,15,20],
		//             1080x1920: [5,10,15,20]
		//         }
		
		formats = {};
		
		camera.formats.forEach(function(format) {
			var new_format
			
			if (!formats[format.format]) {
				formats[format.format] = { formatName: format.formatName, frameSizes: {} };
			}
			
			if (!formats[format.format].frameSizes[String(format.width) + "x" + String(format.height)]) {
				formats[format.format].frameSizes[String(format.width) + "x" + String(format.height)] = [];
			}
			
			if (formats[format.format].frameSizes[String(format.width) + "x" + String(format.height)].indexOf(format.interval.denominator/format.interval.numerator) == -1) {
				formats[format.format].frameSizes[String(format.width) + "x" + String(format.height)].push(format.interval.denominator/format.interval.numerator);
			}
		});
		
		console.log(formats);
		
		var formatSelect = document.getElementById("format-select");
		var frameSelect = document.getElementById("frame-size-select");
		var fpsSelect = document.getElementById("framerate-select");
		
		while (formatSelect.firstChild) {
			formatSelect.removeChild(formatSelect.firstChild);
		}
		
		while (frameSelect.firstChild) {
			frameSelect.removeChild(frameSelect.firstChild);
		}
		
		while (fpsSelect.firstChild) {
			fpsSelect.removeChild(fpsSelect.firstChild);
		}
		
		formatSelect.onchange = updateFormatOptions;
		frameSelect.onchange = updateFrameSizeOptions;
		fpsSelect.onchange = updateFramerateOptions;
		
		for(var format in formats) {
			console.log("checking format:",format); 
			if (formats[format].formatName == "H264") { // h264 only for now
				var option = document.createElement("option");
				option.innerHTML = formats[format].formatName;
				option.value = format;
				if (formats[format].formatName == _activeFormat.format) {
					option.selected = true;
				}
				formatSelect.appendChild(option);
			}
		}
		
		// When asking to update format options,
		// this will result in an update of all others dependent options,
		// like frame size and framerate
		updateFormatOptions();
		
		// Load option from running pipeline
		loadOptions();
	}
	
	function newProfile() {
		var name = prompt("Enter a name for the new profile:");
		saveProfile(name);
	}
	
	function updateProfile() {
		var select = document.getElementById("v4l2 profile select");
		var name = select.options[select.selectedIndex].value;
		saveProfile(name);
	}
	
	function saveProfile(name) {
		if (!name) {
			console.log("no name for profile!");
			return;
		}
		socket.emit("save v4l2 profile", name);
	}
	
	function deleteProfile() {
		var select = document.getElementById("v4l2 profile select");
		var name = select.options[select.selectedIndex].value;
		if (!name) {
			console.log("no name for profile!");
			return;
		}
		socket.emit("delete v4l2 profile", name);
	}
	
	disableAll(true);
	
	socket.emit('get v4l2 cameras'); // get v4l2 options

	// Deal with stream types
	/// Populate valid video stream types
	function populateStreamTypeSelect() {
		// Get combobox and add all options, the value of each option is the string pipeline
		const streamTypeSelect = document.getElementById("stream-type-select")
		for (const [streamType, content] of Object.entries(PIPELINES)) {
			// Create option and add to combobox
			const option = document.createElement("option");
			option.innerHTML = streamType;
			option.value = content.pipeline_elements.join(' ! ')
			
			streamTypeSelect.appendChild(option)
		}
		
		// Menu under streamTypeSelect with all options for each stream type
		var streamTypeMenu = document.getElementById('stream-type-menu')
		//UDP
		{
			// Create a parent item to enable visibity changes of the sub items
			let udpMenu = document.createElement("div")
			udpMenu.id = 'udp-menu'

			let title = document.createElement("h4")
			title.innerHTML = "Clients: "

			let input = document.createElement("input")
			input.id = 'udp-clients'
			input.value = '192.168.2.1:5600'
			
			let info = document.createElement("div")
			info.class = 'alert alert-info'
			info.role = 'alert'
			info.innerHTML = 'Accepts multiple endpoints, E.g: 192.168.2.2:5600,192.168.2.3:5600,...'
			
			title.appendChild(input)
			udpMenu.appendChild(title)
			udpMenu.appendChild(info)
			streamTypeMenu.appendChild(udpMenu)
		}

		// RTSP
		{
			// No menu for now
		}
		
		// Update visibility
		streamTypeChanged()
	}
	
	/// Check if the video stream type changed
	function streamTypeChanged() {
		// Get component and selected option
		const streamTypeSelect = document.getElementById("stream-type-select")
		const option = streamTypeSelect.options[streamTypeSelect.selectedIndex]
		
		// Use the selected option to make the `option-menu` visible and others hidden
		for (const [streamType, _] of Object.entries(PIPELINES)) {
			const menuName = streamType + '-menu'
			var item = document.getElementById(menuName)
			if (item == null) {
				console.log(`Component: ${menuName} does not exist or is not ready yet.`)
				break
			}
			const visible = streamType == option.innerHTML
			item.style.visibility = visible ? 'visible' : 'hidden'
			item.style.display = visible ? 'block' : 'none'
		}
	}

	// Set default gstreamer configuration
	function setDefaultGstreamerConfiguration() {
		const streamType = "udp"
		const frameSize = [1920, 1080].join('x')
		const frameRate = 30

		changeStreamType(streamType)

		console.log(`Updating selected frame size to: ${frameSize}`)
		$('#frame-size-select').val(frameSize).change()

		console.log(`Updating selected framerate to: ${frameRate}`)
		$('#framerate-select').val(frameRate).change()

		applyGstreamer()
	}

	// Apply Gstreamer pipeline
	function applyGstreamer() {
		// Get selected stream option
		const streamTypeSelect = document.getElementById("stream-type-select")
		const option = streamTypeSelect.options[streamTypeSelect.selectedIndex]
		const stream_type = option.innerHTML
		
		/// Crete necessary variables for the pipeline
		// Generic variables
		const camera = getCameraSelection()
		const [width = 1920, height = 1080] = getFrameSizeSelection().split('x')
		const framerate = getFpsSelection()
		
		const clients = (function() {
			switch (stream_type) {
				case 'udp':
					return document.getElementById("udp-clients").value
					break
				case 'rtsp':
					return '{service_ip}:8554/video1'
					break
				default:
					console.error(`Invalid stream option ${stream_type}, aborting!`)
					return;
			}
		})()
		
		// Create endpoint from clients (comma separated list)
		const endpoint = PIPELINES[stream_type].endpoint_prefix + clients.split(',')[0]
		
		// Create final pipeline
		const pipeline = eval('`' + option.value + '`')
		
		// Create video configuration for camera-manager
		const videoConfiguration = {
			'device': camera,
			'pipeline': pipeline,
			'endpoint': endpoint,
		}
		
		const jsonVideoConfiguration = JSON.stringify(videoConfiguration)
		console.log(`About to send video configuration: ${jsonVideoConfiguration}`)
		
		// Send camera pipeline
		$.ajax({
			type: 'POST',
			url: '/pipelines/0',
			data: jsonVideoConfiguration,
			dataType: 'json',
			contentType: "application/json",
		});
	}
	
</script>

<h1 id="camera setup">Camera Setup</h1>

<div class="row">
	<div class="col-md-6">
		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">Streaming Settings</h3>
			</div>
			<div class="panel-body">
					<h4>Camera:
						<select id="camera-select"></select>
					</h4>
					<h4>Format:
						<select id="format-select"></select>
					</h4>
					<h4>Frame Size (width x height):
						<select id="frame-size-select"></select>
					</h4>
					<h4>Frame Rate (FPS):
						<select id="framerate-select"></select>
					</h4>
					
					<div class="panel panel-default">
						<div class="panel-heading">
							<h3 class="panel-title">Streaming Settings</h3>
						</div>
						<div id="stream-type-menu" class="panel-body">
							<h4>Stream type:
								<select id="stream-type-select" onchange="streamTypeChanged()">
									<script>populateStreamTypeSelect()</script>
								</select>
							</h4>
						</div>
					</div>

					<button id="reset-gst" class="btn btn-secondary"
						onclick="setDefaultGstreamerConfiguration()">Set Default</button>
					<button id="update-gst" class="btn btn-primary"
						onclick="applyGstreamer()">Apply</button>
			</div>
		</div>
	</div>
	<div class="col-md-6">
		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">Camera Settings</h3>
			</div>
			<div class="panel-body">
					<h4>Preset Profile:
						<select id="v4l2 profile select"></select>
					</h4>
					<button class="btn btn-primary"
						onclick="resetDefaults()">Reset to Defaults</button>
					<button class="btn btn-primary" 
						onclick="newProfile()">New Profile</button>
					<button class="btn btn-primary" 
						onclick="updateProfile()">Update Profile</button>
					<button class="btn btn-primary" 
						onclick="deleteProfile()">Delete Profile</button>

					<div id="v4l2controls"></div>
			</div>
		</div>
	</div>
</div>

{% include ../_includes/footer.liquid %}
